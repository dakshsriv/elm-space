-- Create your spaceship!
-- SmallModel includes textures and meshes
mySpaceship : SmallModel -> Spaceship
mySpaceship model =
    let
        useTexture = getTexture model.textureLoader.textures
    in

    {
        commandModule = group3D
            [
                cone 400 600 |> matte Color.gray
                        |> move3D (0, 0 , 2000),
                polygon3D 3 60
                |> metallic Color.gray 1
                |> scale3D 20
                |> rotateY3D (degrees -90)
                |> move3D (0,0,10)
            ]
    ,   parts = [                                      -- a list of parts in your spaceship
                    saturnV "thruster1a"
                        |> rotatePart (Angle.degrees 0) (Angle.degrees 0) (Angle.degrees 0)
                        |> movePart (Length.meters -2, Length.meters -2, Length.meters -7.9)
                ,   saturnV "thruster1b"
                        |> rotatePart (Angle.degrees 0) (Angle.degrees 0) (Angle.degrees 0)
                        |> movePart (Length.meters 2, Length.meters -2, Length.meters -7.9)
                ,   saturnV "thruster1c"
                        |> rotatePart (Angle.degrees 0) (Angle.degrees 0) (Angle.degrees 0)
                        |> movePart (Length.meters -2, Length.meters 2, Length.meters -7.9)
                ,   saturnV "thruster1d"
                        |> rotatePart (Angle.degrees 0) (Angle.degrees 0) (Angle.degrees 0)
                        |> movePart (Length.meters 2, Length.meters 2, Length.meters -7.9)
                ,   addFuelTank "fueltank1" (Length.meters 8) (Length.meters 13) 100
                        |> movePart (Length.meters 0, Length.meters 0, Length.meters -5)
                ,   addStabilizer "stabilizer" (Length.meters 4) (Length.meters 0.5)
                        |> movePart (Quantity.zero, Quantity.zero, Length.meters 20)
                 ,   saturnV "thruster2a"
                                          |> rotatePart (Angle.degrees 180) (Angle.degrees 0) (Angle.degrees 0)
                                          |> movePart (Length.meters 0, Length.meters 0, Length.meters 21)
                ,   saturnV "thruster2b"
                                          |> rotatePart (Angle.degrees 180) (Angle.degrees 0) (Angle.degrees 0)
                                          |> movePart (Length.meters 0, Length.meters 0, Length.meters -7.9) 

                         ]
    ,  keyActions = \ key keyAction ->
            case (key, keyAction) of
                (Spacebar, Pressed) ->
                    ManyActions
                        [
                            EnableThruster "thruster1a" 100
                        ,   EnableThruster "thruster1b" 100
                        ,   EnableThruster "thruster1c" 100
                        ,   EnableThruster "thruster1d" 100
                        ]
                (Spacebar, Released) ->
                    ManyActions
                        [
                            DisableThruster "thruster1a"
                        ,   DisableThruster "thruster1b"
                        ,   DisableThruster "thruster1c"
                        ,   DisableThruster "thruster1d"
                        ,   EnableStabilizer "stabilizer"
                        ]
                --W
                (Key "d", Pressed) ->
                    ManyActions
                        [
                            EnableThruster "thruster1a" 7.5  
                        ,   EnableThruster "thruster1c" 7.5
                        ]
                (Key "d", Released) ->
                    ManyActions
                        [
                            DisableThruster "thruster1a"
                        ,   DisableThruster "thruster1c"
                        ,   EnableStabilizer "stabilizer"
                        ,   EnableStabilizer "stabilizer"
                        ]
                --S        
                (Key "a", Pressed) ->
                    ManyActions
                        [
                            EnableThruster "thruster1b" 7.5
                        ,   EnableThruster "thruster1d" 7.5
                        ]
                (Key "a", Released) ->
                    ManyActions
                        [
                            DisableThruster "thruster1b"
                        ,   DisableThruster "thruster1d"
                        ,   EnableStabilizer "stabilizer"
                        ]
                --A
                (Key "w", Pressed) ->
                    ManyActions
                        [
                            EnableThruster "thruster1d" 7.5
                        ,   EnableThruster "thruster1c" 7.5
                        ]
                (Key "w", Released) ->
                    ManyActions
                        [
                            DisableThruster "thruster1d"
                        ,   DisableThruster "thruster1c"
                        ,   EnableStabilizer "stabilizer"
                        ]
                --D
                (Key "s", Pressed) ->
                    ManyActions
                        [
                            EnableThruster "thruster1a" 7.5
                        ,   EnableThruster "thruster1b" 7.5
                        ]
                (Key "s", Released) ->
                    ManyActions
                        [
                            DisableThruster "thruster1a"
                        ,   DisableThruster "thruster1b"
                        ,   EnableStabilizer "stabilizer"
                        ]
                (Key "Shift", Pressed) ->
                    ManyActions
                        [
                            EnableThruster "thruster2a" 300
                        ,   EnableThruster "thruster2b" 300
                        ]
                (Key "Shift", Released) ->
                    ManyActions
                        [
                            DisableThruster "thruster2a"
                        ,   DisableThruster "thruster2b" 
                        ,   EnableStabilizer "stabilizer"
                        ]                        
--                (Key "w", Pressed) -> EnableThruster "thruster1a" 200
                _ -> DoNothing
                 -- a list of keys and actions they do

                 -- a list of keys and actions they do
    }

-- You can change the colour of your UI
colourUI =
    GraphicSVG.hsl (degrees 150) 1 0.5
colourUIText =
    GraphicSVG.white

-- Set this to true if you want the spaceship to fly according to the flight plan below
-- Or false if you want to just fly it yourself
useAutoPilot = False

-- You can use this to program how your spaceship flies!
autoPilotRoutine : Float -> Action
autoPilotRoutine =
    animationPieces
        [ ( 5.0 -- This will fire your forward thrusters for 5 seconds. Try changing it!
          , \ time -> 
              ManyActions
                  [ EnableThruster "thruster1a" 100
                  , EnableThruster "thruster1b" 100
                  , EnableThruster "thruster1c" 100
                  , EnableThruster "thruster1d" 100
                  ]
          )
        , ( 0.1 -- This will turn off those thrusters
          , \ time -> 
              ManyActions
                  [ DisableThruster "thruster1a"
                  , DisableThruster "thruster1b"
                  , DisableThruster "thruster1c"
                  , DisableThruster "thruster1d"
                  ]
          )
        ]
        ( \ _ -> 
              DoNothing
        )

-- Create your own space station!!
-- space station is 350 km above the Earth
spaceStationSize = (Length.inCentimeters <| Length.meters 20)

spaceStation model =
    let
        useTexture = getTexture model.textureLoader.textures
    in
        group3D
            [
              box 20 200 15
                |> matte (Color.rgb255 232 226 209)
              , rectangle3D 100 50
                |> textured (useTexture "solarcell") 0.5 0.5
                |> rotateY3D (degrees 90)
                |> move3D (0,100,0)
              , rectangle3D 100 50
                |> textured (useTexture "solarcell") 0.5 0.5
                |> rotateY3D (degrees 90)
                |> move3D (0,-100,0)
            ]


-- Use "loadTexture [name] [url]" to load in texture images from the Internet!
-- Give each one a unique name.
-- You can list many of them!
myTextures = 
    [ loadTexture "earth" "https://raw.githubusercontent.com/CSchank/CSchank.github.io/master/img/Earth.png"
    , loadTexture "dec" "https://sharyuwu.github.io/image/dec.png"
    , loadTexture "decBroken1" "https://sharyuwu.github.io/image/decBroken1.png"
    ]

-- Usage: `svgTexture "name" "name`, where shape is any 2D shape or group
-- Give each one a unique name.
-- You can list many of them!
svgTextures =
    [ svgTexture "squares" squares
    , svgTexture "solarcell" solarCellsvg
    ]

-- SVG textures are 50 by 50
squares =
    group
        [ square 25 |> filled purple |> move (12.5,12.5)
        , square 25 |> filled orange |> move (-12.5,12.5)
        , square 25 |> filled purple |> move (-12.5,-12.5)
        , square 25 |> filled orange |> move (12.5,-12.5)
        ]

-- Put your 2D shapes here, and they will be overlayed on top of the screen!
overlay : Model -> List (Shape Msg)
overlay model =
    [ angleDisplay model
    , spaceshipDebug "spaceship" model 30 colourUI colourUIText
    , spaceGameUI model
    , cameraUI model
    ]

-- Here you can specify what images to use to create the skybox. Just replace "todo" with a link to an image. (Keep the quotes, though!)
skyboxType =
    --Skybox.URLSkybox textureBottom textureTop textureSide1 textureSide2 textureSide3 textureSide4
    -- Some other options (comment in the one above and comment one of these out)
    -- Skybox.GSVGSkybox False skyboxTop skyboxSides skyBoxBottom
    -- Skybox.GSVGSphericalSkybox False skyboxTop
    Skybox.URLSphericalSkybox "https://cschank.github.io/img/milky.jpg"

-- this is 50 by 50
skyboxTop : Shape msg
skyboxTop =
    group
        [
            square 50 |> filled lightBlue
        ,   circle 10 |> filled yellow
        ]

-- this is 200 by 50
skyboxSides : Shape msg
skyboxSides =
    group
        [
            rect 200 50 |> filled lightBlue |> move (0,25)
        ,   rect 200 50 |> filled green |> move(0,-25)
        ,   triangle 10 |> filled darkGreen |> rotate (degrees -30) |> move (0,5)
        ,   text "abcdefghijklmnopqrstuvwxyz" |> centered |> size 16 |> filled red
        ]

-- this is 50 by 50
skyBoxBottom : Shape msg
skyBoxBottom =
    group
        [
        ]


textureBottom : String
textureBottom =
    "todo"

textureTop : String
textureTop =
    "todo"

textureSide1 : String
textureSide1 =
    "todo"

textureSide2 : String
textureSide2 =
    "todo"

textureSide3 : String
textureSide3 =
    "todo"

textureSide4 : String
textureSide4 =
    "todo"

-- ----------------------------------------------- Hardcode below ---------------------------------------------------

type alias SmallModel =
    { meshStore : MeshStore BodyCoordinates, textureLoader : TextureLoader.Model }

-- Time in seconds for fixing the satellite
levelAdjust = 10

internalSpaceStation model =
    let
        useTexture = getTexture model.textureLoader.textures
    in
      (if model.showDetailedSpaceStation then spaceStation model else cube 1 |> matte Color.black)
          |> scaleTo3D spaceStationSize Direction3d.x
          |> rotateY3D (degrees 90)
          |> spaceStationOrbit model

spaceGameUI model =
    let
        showCaution =
            if earthToShip model |> Quantity.lessThan (Length.kilometers 10) then
                0.6 + 0.4 * sin (5 * model.time - 1.5)
            else 0
        showGameOver =
            if model.ifGameOver then
                1
            else
                0
        showRepair =
            if model.ifRepair then
                1
            else
                0
        fixprocess = 
            case model.startRepairtime of
                NotStarted ->
                    0
                Started time ->
                    modBy (levelAdjust + 1) (round (model.time - time))

        spaceshipPosition =
            Maybe.withDefault Point3d.origin <| Maybe.map (Frame3d.originPoint << Body.frame)
                <| List.head <| World.bodies model.spaceshipState.world

        satellitePosition =
            getPosition (satelliteModel model)
        spaceStationPosition =
            getPosition (internalSpaceStation model)

        distanceToSatellite =
            Length.inKilometers <| Vector3d.length <| Vector3d.from spaceshipPosition satellitePosition
        distanceToSpaceStation =
            Length.inKilometers <| Vector3d.length <| Vector3d.from spaceshipPosition spaceStationPosition
    in
        group
            [ cautionSign model (earthToShip model) |> makeTransparent showCaution
            --, satelliteSign model (satelliteToShip model) |> makeTransparent (0.6 + 0.4 * sin (5 * model.time - 1.5))
            , repair model (toFloat fixprocess) levelAdjust |> makeTransparent showRepair
            , missionFailSign model |> scale 3 |> makeTransparent showGameOver
            , move (-60, 0) <| GraphicSVG.map SpaceshipMsg <| SpaceshipPart.overlay model.width model.height colourUI model.spaceshipState
            , text
                ( "Mission Time: T+" ++ Round.round 3 model.gameTime ++ "s" )
              |> centered
              |> customFont "Audiowide"
              |> size 24
              |> filled colourUIText
              |> move ( 0, toFloat (unwrapQ model.height) / 2 - 50 )
            , tracker
                model.camera
                model
                (getPosition <| satelliteModel model)
                20
                colourUI
                colourUI
                ("satellite (" ++ Round.round 3 distanceToSatellite ++ "km)")
                False
            , tracker
                model.camera
                model
                (getPosition <| internalSpaceStation model)
                20
                colourUI
                colourUI
                ("space station (" ++ Round.round 3 distanceToSpaceStation ++ "km)")
                False
            ]

cameraUI model =
    group
        [ group
              [ roundedRect 40 40 10
                |> filled colourUI
              , text "+"
                |> size 16
                |> centered
                |> customFont "Audiowide"
                |> filled colourUIText
                |> move (0,-2.5)
                |> rotate (degrees 180)
              ]
            |> move (toFloat (unwrapQ model.width) / 2 - 125, toFloat (unwrapQ model.height) / 2 - 150)
            |> notifyTap (ChangeZoom <| Length.meters -10)
        , group
              [ roundedRect 40 40 10
                |> filled colourUI
              , text "-"
                |> size 16
                |> centered
                |> customFont "Audiowide"
                |> filled colourUIText
                |> move (0,-2.5)
                |> rotate (degrees 180)
              ]
            |> move (toFloat (unwrapQ model.width) / 2 - 125, toFloat (unwrapQ model.height) / 2 - 200)
            |> notifyTap (ChangeZoom <| Length.meters 10)
        , group
            [ roundedRect 140 60 10
              |> filled colourUI
            , text "Cycle Camera"
              |> size 16
              |> centered
              |> customFont "Audiowide"
              |> filled colourUIText
              |> move (0, -5)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 125, toFloat (unwrapQ model.height) / 2 - 260)
          |> notifyTap CycleCameraState
        ]

spaceshipDebug objToTrack model trackerSize trackerColour textColour =
    let
        toTrack = getBodyByName objToTrack model.spaceshipState.world
        trackingName =
            case toTrack of
                Just body ->
                    (Body.data body).name
                Nothing ->
                    "Nothing"
        textLeft = -300 * toFloat (unwrapQ model.width) / 1920
        bodyInfo =
            case toTrack of
                Just body ->
                    let
                        frame = Body.frame body
                        vectorToString vector =
                            "{ x = " ++ Round.round 2 (unwrapQ (Vector3d.xComponent vector)) ++ "m/s, y = " ++ Round.round 2 (unwrapQ (Vector3d.yComponent vector)) ++ "m/s, z = " ++ Round.round 2 (unwrapQ (Vector3d.zComponent vector)) ++ "m/s }"
                        pointToString point =
                            let
                                (x, y, z) = Point3d.toTuple Length.inMeters point
                            in
                                "{ x = " ++ Round.round 2 x ++ "m, y = " ++ Round.round 2 y ++ "m, z = " ++ Round.round 2 z ++ "m }"
                        dirToString dir =
                            "{ x = " ++ Round.round 2 (Direction3d.xComponent dir) ++ ", y = " ++ Round.round 2 (Direction3d.yComponent dir) ++ ", z = " ++ Round.round 2 (Direction3d.zComponent dir) ++ " }"
                    in
                        group
                            [ text ("Name: " ++ trackingName) |> customFont "Audiowide" |> filled textColour |> move (textLeft,50)
                            , text ("Velocity: " ++ vectorToString (Body.velocity <| body)) |> customFont "Audiowide" |> filled textColour |> move (textLeft,35)
                            , text ("Origin Point: " ++ pointToString (Frame3d.originPoint <| frame)) |> customFont "Audiowide" |> filled textColour |> move (textLeft,20)
                            , text ("Rotational velocity: " ++ vectorToString (Body.angularVelocity <| body)) |> customFont "Audiowide" |> filled textColour |> move (textLeft,5)
                            , text ("x direction: " ++ dirToString (Frame3d.xDirection <| frame)) |> customFont "Audiowide" |> filled textColour |> move (textLeft,-10)
                            , text ("y direction: " ++ dirToString (Frame3d.yDirection <| frame)) |> customFont "Audiowide" |> filled textColour |> move (textLeft,-25)
                            , text ("z direction: " ++ dirToString (Frame3d.zDirection <| frame)) |> customFont "Audiowide" |> filled textColour |> move (textLeft,-40)
                            , text (Debug.toString (Body.data body).visualizers) |> customFont "Audiowide" |> filled textColour |> move (textLeft,-55)
                            ] |> scale (2 * (toFloat (unwrapQ model.height) / 970)) |> move (0, -250 * toFloat (unwrapQ model.height) / 970)
                Nothing ->
                    text "Error: Invalid Physics Body" |> centered |> filled textColour
        theTracker = bodyTracker objToTrack model trackerSize trackerColour textColour True
    in
    group
        [ bodyInfo
        --, theTracker
        ]

spaceStationOrbit model object = 
  let
    spaceStationtoEarth = (Length.inCentimeters <| Length.kilometers 150)
  in
    object
        |> move3D (0, Length.inCentimeters <| Length.meters 300, 0)
     -- |> move3D (0,(Length.inCentimeters <| Length.kilometers -100),0)
     -- |> move3D (0, 0, earthSize)
     -- |> move3D (0, 0, spaceStationtoEarth)
    --  |> move3D (0, (Length.inCentimeters <| Length.meters ((cos model.time) * 10)), (Length.inCentimeters <| Length.meters (-(sin model.time) * 10)))

-- Earth has a radius of 3,959 miles
-- A distance from earth to satellite is 36,000 km
earthSize = (Length.inCentimeters <| Length.kilometers 100)
satelliteSize = (Length.inCentimeters <| Length.meters 20)

spaceGameAssist : Model -> List (Object WorldCoordinates)
spaceGameAssist model =
        [   
         earthModel model
            |> move3D (0,Length.inCentimeters <| Length.kilometers 100,0)
          ,
          satelliteModel model
        ]

earthModel model =    
    let
        useTexture = getTexture model.textureLoader.textures
    in group3D
    [
      sphere earthSize
            |> textured (useTexture "earth") 0 0
            |> rotateZ3D (degrees model.time)
    ]

satelliteModel model = 
    let
        useTexture = getTexture model.textureLoader.textures
        earthToSatellite = (Length.inCentimeters <| Length.kilometers 100)
    in
     group3D [
    (if model.showDetailedSatellite then
     satellite model model.ifSatelliteBroken else cube 1 |> matte Color.black)
            |> rotateY3D (degrees 180)
            |> scaleTo3D satelliteSize Direction3d.y
            |> move3D (0,Length.inCentimeters <| Length.kilometers 150,0)
            |> move3D (0, -earthToSatellite, 0)
            |> move3D (0, -earthToSatellite, earthSize/2)
    ]

-- Satellite Code
satellite model ifBreaken =  
    let
        useTexture = getTexture model.textureLoader.textures
        dec = if ifBreaken then "decBroken1"
             else "dec"
    in group3D
        [ -- Making an ellipsoid requires you to specify the length, width, and height. You also need to pass in the model.
        cylinder 20 15
          |> matte (Color.rgb255 222 218 211)
        ,cylinder 25 20 
          |> matte (Color.rgb255 222 218 211)
        ,cylinder 25 10
          |> matte (Color.rgb255 222 218 211)
          |> move3D (0,0,-20)
        ,cylinder 30 25
          |> matte (Color.rgb255 222 218 211)
          |> move3D (0,0,-30)
        ,cylinder 25 10
          |> matte (Color.rgb255 222 218 211)
          |> move3D (0,0,-40)
        ,cylinder 26 20
          |> matte (Color.rgb255 222 218 211)
          |> rotateZ3D (degrees 180)
          |> move3D (0,0,-50) 
        ,cylinder 20 20
          |> matte (Color.rgb255 222 218 211)
          |> move3D (0,0,-70)
        , wing1 model ifBreaken
        , wing2 model ifBreaken
        ,truncatedCone 10 20 15 model.meshStoreWorld
          |> matte (Color.rgb255 222 218 211)
          |> rotateX3D (degrees 180)
          |> move3D (0,0,15)
          |> scale3D 2
        ,link
          |> rotateX3D (degrees 90)
          |> move3D (15,0,-16.5)
          |> scale3D 0.9
        ,link
          |> rotateX3D (degrees 90)
          |> move3D (15,0,16.5)
          |> scale3D -0.9
        , cube 5
          |> matte (Color.rgb255 222 218 211)
          |> move3D (-2.5,-2.5,45)
        , linkDish
        , linkDish
          |> rotateZ3D (degrees 90) 
        ]
wing1 model ifBreaken =  
    let
        useTexture = getTexture model.textureLoader.textures
    in
     if ifBreaken then
        group3D [customPolygon brokenWingPoint
             |> textured (useTexture "solarcell") 1 1
             |> rotateZ3D (degrees 90)
             |> move3D (100,-30,-15)
             |>scale3D 0.95
        ]
     else
        rectangle3D 100 50
             |> textured (useTexture "solarcell") 0.5 0.5
             |> move3D (100,0,-15)
wing2 model ifBreaken =  
    let
        useTexture = getTexture model.textureLoader.textures
    in
     if ifBreaken then
        rectangle3D 100 50
          |> textured (useTexture "solarcell") 1 1
          |> move3D (-100,0,-15)
     else
        rectangle3D 100 50
          |> textured (useTexture "solarcell") 0.5 0.5
          |> move3D (-100,0,-15)
brokenWingPoint = 
   [(2.1512,46.789),(58.442,47.148),(59.159,3.0476),(53.422,-5.557),(50.196,0.8963),(45.893,-5.198),(41.232,-9.859),(34.778,-3.764),(34.420,-10.93),(25.815,-7.708),(20.078,3.4061),(14.341,-13.44),(11.831,-15.59),(6.8123,-10.93),(5.0196,-16.31),(0.7170,-12.01),(2.1512,46.789)]

linkDish = group3D [
        cylinder 0.5 45
          |> matte (Color.rgb255 222 218 211)
          |> rotateY3D (degrees 180)
          |> rotateY3D (degrees -45)
          |> move3D (0,0,50)
        , cylinder 0.5 45
          |> matte (Color.rgb255 222 218 211)
          |> rotateY3D (degrees -180)
          |> rotateY3D (degrees 45)
          |> move3D (0,0,50)
  ]
link = group3D [
        cylinder 0.5 40
          |> matte (Color.rgb255 222 218 211)
          |> rotateY3D (degrees 90)
        ,cylinder 0.5 50
          |> matte (Color.rgb255 222 218 211)
          |> rotateY3D (degrees 55)
        ,cylinder 0.5 50
          |> matte (Color.rgb255 222 218 211)
          |> rotateY3D (degrees 125)
  ]

-- SVG textures for solar cell
rectW = 13
rectH = 18
scW = 3
scH = 3
sgW = 6
sgH = 4

solarCellsvg = group
  [
    rect (rectW*scW*4) (rectH*scH*4)
      |> filled white
    ,solarGroup sgW sgH
      |> move (-(rectW*scW)*sgW/3.2 , -(rectH*scH)*sgH/3)
  ]

solarGroup a b = group
  <| List.map (\x -> solarcell scW scH |> move x |>scale 0.3) (layoutWH a b (rectW*scW*2) (rectH*scH*2))


solarcell a b = group
  <| List.map (\x -> solarelm |> move x) (layoutWH a b (rectW*2) (rectH*2))


solarelm = group [
    rect 10 15
     |> filled (rgb 50 76 168)
    ,rect 10 15
     |> filled (rgb 50 76 168)
     |> move (rectW, 0)
    ,rect 10 15
     |> filled (rgb 50 76 168)
     |> move (0, rectH)
    ,rect 10 15
     |> filled (rgb 50 76 168)
     |> move (rectW, rectH)
   ]
   
layout15 a width = List.map (\x -> width * toFloat(x)) (List.range 0 (a-1))

layoutWH a b width height = List.concat 
                  <| List.map (\x -> List.map (\y -> ( y, height * toFloat (x))) (layout15 a width)
                        ) (List.range 0 (b-1))


repair model process total =
  group [
    rect (10 * process )  30
      |> filled orange
      |> move (-(10 * total)/2+5 + (5 * (process-1)), 0)
    , rect (10 * total ) 30
      |> outlined (solid 1) orange
    , text "REPAIRING"
      |> customFont "Audiowide"
      |> size 11
      |> centered
      |> filled black
      |> move (0, -5)
  ]


-- Caution sign. Show this sign when the rocket is too close to earth
cautionSign model distance = group
  [
    rect 200 30
      |> filled (rgb 252 198 3)
    , rect 190 20
      |> filled (rgb 255 207 31)
      |> makeTransparent 1
    , triangle 8
      |> filled black
      |> rotate (degrees 90)
      |> move (-85, -1)
    , text "!"
      |> customFont "Audiowide"
      |> size 11
      |> centered
      |> filled yellow
      |> move (-85, -4)
    , text ( "CAUTION " ++ Round.round 3 (distance |> Length.inKilometers) ++ " KM" )
      |> customFont "Audiowide"
      |> size 13
      |> centered
      |> filled black
      |> move (10, -5)
  ]

-- Mission fail sign. Show this sign when the rocket bump into earth
-- or satellite

missionFailSign model =
  group [
    rect 100 30
      |> filled white
    , rect 100 30
      |> outlined (solid 3) red
    , text "MISSION FAILED"
      |> customFont "Audiowide"
      |> size 11
      |> centered
      |> filled red
      |> move (0, -5)
  ] |> rotate (degrees 15)

satelliteSign model distance = group
  [
    rect 120 30
      |> filled (rgb 96 65 181)
    , rect 110 20
      |> filled (rgb 173 143 255)
      |> makeTransparent 0.5
    , text ("REPAIR" ++ String.fromInt distance ++ " m")
      |> customFont "Audiowide"
      |> size 14
      |> centered
      |> filled white
      |> move (-25, -5)
  ]

-- calculate the distance from earth to ship
earthToShip model =
    let
        spaceshipPosition =
            model.spaceshipState.world
            |> getBodyByName "spaceship"
            |> Maybe.map Body.originPoint
            |> Maybe.withDefault Point3d.origin

        earthPosition = getPosition <| earthModel model
        distance =
            earthPosition
            |> Point3d.distanceFrom spaceshipPosition
    in
        distance

-- calculate the distance from satellite to ship
satelliteToShip model =
  let

     spaceshipPosition =
        Maybe.withDefault Point3d.origin <| Maybe.map (Frame3d.originPoint << Body.frame)
            <| List.head <| World.bodies model.spaceshipState.world

     satellitePosition = getPosition <| satelliteModel model
     distanceToSpaceStation = Length.inMeters <| Vector3d.length <| Vector3d.from spaceshipPosition satellitePosition
  in
     distanceToSpaceStation

debugMeshNames model = text (Debug.toString (List.map (\(key,_) -> key) (Dict.toList model.meshStore.generatedMeshes))) |> filled black

type CameraState
    = Orbiting
    | SpaceshipForwards

type alias Model =
    { width : Quantity Int Pixels
    , height : Quantity Int Pixels
    , time : Float
    , gameTime : Float
    , orbiting : Bool
    , azimuth : Angle
    , elevation : Angle
    , cameraPos : Point3d Meters WorldCoordinates
    , camera : Camera3d Meters WorldCoordinates
    , cameraState : CameraState
    , meshStore : MeshStore BodyCoordinates
    , meshStoreWorld : MeshStore WorldCoordinates
    , widget : Widget.Model
    , gSkyboxModel : GS.Model
    , gTextureModel : GT.Model
    , textureLoader : TL.Model
    , world : World PhysicsData
    , state : State
    , spaceshipState : SpaceshipPart.Model
    , ifSatelliteBroken : Bool
    , ifRepair : Bool
    , ifGameOver : Bool
    , startRepairtime : RepairTime
    , cameraZoom : Length
    , showDetailedSatellite : Bool
    , showDetailedSpaceStation : Bool
    }

type RepairTime
   = Started Float 
   | NotStarted

type State
    = Loaded
    | Loading

type Msg
    = Resize (Quantity Int Pixels) (Quantity Int Pixels)
    | Tick Duration
    | MouseDown
    | MouseMove (Quantity Float Pixels) (Quantity Float Pixels)
    | MouseUp
    | VisibilityChange Browser.Events.Visibility
    | GenerateMeshes (List (Object WorldCoordinates)) CoordType
    | WidgetMsg Widget.Msg
    | Reset
    | MoveCamera (Direction3d WorldCoordinates) Length
    | SkyboxMsg GS.Msg
    | GSVGTextureMsg GT.Msg
    | TextureLoadMsg TL.Msg
    | AddBodies
    | SpaceshipMsg SpaceshipPart.Msg
    | ChangeZoom Length
    | CycleCameraState

type CoordType
    = WorldCoords
    | BodyCoords

{-| Create both a Light and an Entity (a bright glowing sphere) representing a
particular point light
-}
pointLight :
    { position : Point3d Meters WorldCoordinates
    , chromaticity : Chromaticity
    , intensity : LuminousFlux
    }
    -> ( Light WorldCoordinates Never, Entity WorldCoordinates )
pointLight properties =
    let
        -- Create a sphere to represent a light bulb
        lightsphere =
            Sphere3d.atPoint properties.position (Length.kilometers 5)

        -- Calculate the luminance of the sphere surface by dividing the given
        -- total luminous flux of the light by the surface area of the sphere
        -- and by the solid angle of a hemisphere (assuming that each point on
        -- the surface of the bulb emits light equally in all directions)...I
        -- am not 100% sure this is exactly correct =)
        sphereLuminance =
            properties.intensity
                |> Quantity.per (SolidAngle.spats 0.5)
                |> Quantity.per (Sphere3d.surfaceArea lightsphere)

        -- Create an emissive (glowing) material for the sphere
        sphereMaterial =
            Material.emissive properties.chromaticity sphereLuminance
    in
    ( Light.point Light.neverCastsShadows properties
    , Scene3d.sphere sphereMaterial lightsphere
    )


view : Model -> Html Msg
view model =
    let
        -- The sun
        (sunLighting, sun) =
            pointLight
                {
                    position = Point3d.fromTuple Length.kilometers (0, -200, 0)
                ,   chromaticity = Light.sunlight
                ,   intensity = LuminousFlux.lumens 200000000000000
                }
        softLighting = Light.soft
                { upDirection = Direction3d.positiveZ
                , chromaticity = Light.fluorescent
                , intensityAbove = Illuminance.lux 15
                , intensityBelow = Illuminance.lux 15
                }

        spaceshipFrame = SpaceshipPart.spaceshipFrame model.spaceshipState

        thrustersOn =
            List.map .position <|
                List.filter (\t -> t.thrustPercent > 0) <| Dict.values model.spaceshipState.spaceshipState.thrusterStates

        thrusterLight : Point3d Meters BodyCoordinates -> Light WorldCoordinates Never
        thrusterLight pt =
            let
                globalPt = pt |> Point3d.placeIn spaceshipFrame
            in
                Tuple.first <| pointLight
                    {
                        position = globalPt
                    ,   chromaticity = Light.color Color.orange
                    ,   intensity = LuminousFlux.lumens 1000000
                    }

        lights =
            case thrustersOn of
                [] -> Scene3d.twoLights sunLighting softLighting
                l1::[] -> Scene3d.threeLights sunLighting (thrusterLight l1) softLighting
                l1::l2::[] -> Scene3d.fourLights sunLighting (thrusterLight l1) (thrusterLight l2) softLighting
                l1::l2::l3::[] -> Scene3d.fiveLights sunLighting (thrusterLight l1) (thrusterLight l2) (thrusterLight l3) softLighting
                l1::l2::l3::l4::[] -> Scene3d.sixLights sunLighting (thrusterLight l1) (thrusterLight l2) (thrusterLight l3) (thrusterLight l4) softLighting
                l1::l2::l3::l4::l5::[] -> Scene3d.sevenLights sunLighting (thrusterLight l1) (thrusterLight l2) (thrusterLight l3) (thrusterLight l4) (thrusterLight l5) softLighting
                l1::l2::l3::l4::l5::l6::rest -> Scene3d.eightLights sunLighting (thrusterLight l1) (thrusterLight l2) (thrusterLight l3) (thrusterLight l4) (thrusterLight l5) (thrusterLight l6) softLighting
                --l1::l2::l3::l4::l5::l6::l7::rest -> Scene3d.eightLights sunLighting (thrusterLight l1) (thrusterLight l2) (thrusterLight l3) (thrusterLight l4) (thrusterLight l5) (thrusterLight l6) (thrusterLight l7)

        textures = model.textureLoader.textures

        baseEntities =
            [ sun
            , case skyboxType of
                Skybox.GSVGSkybox _ _ _ _ ->
                    Skybox.skybox 
                        [ Dict.get "skyB" textures
                        , Dict.get "skyT" textures
                        , Dict.get "skyS1" textures
                        , Dict.get "skyS2" textures
                        , Dict.get "skyS3" textures
                        , Dict.get "skyS4" textures
                        ]
                        0
                Skybox.URLSkybox _ _ _ _ _ _ ->
                    Skybox.skybox 
                        [ Dict.get "skyB" textures
                        , Dict.get "skyT" textures
                        , Dict.get "skyS1" textures
                        , Dict.get "skyS2" textures
                        , Dict.get "skyS3" textures
                        , Dict.get "skyS4" textures
                        ]
                        0
                Skybox.URLSphericalSkybox _ ->
                    Skybox.roundSkybox
                        (Dict.get "skyT" textures)
                        (Length.inCentimeters <| Length.kilometers 1000)
                Skybox.GSVGSphericalSkybox _ _ ->
                    Skybox.roundSkybox
                        (Dict.get "skyT" textures)
                        5000
            ]

    in
        case model.state of
            Loaded ->
                Html.div []
                    [   case skyboxType of
                            Skybox.GSVGSkybox debug sT sS sB ->
                                Html.div [style "position" "absolute", style "left" "0px", style "top" (String.fromInt (unwrapQ model.height) ++ "px")]
                                [
                                    -- Html.h1 [] [Html.text "Skybox Debug"]
                                Html.map SkyboxMsg <| GS.drawSkybox debug model.gSkyboxModel sT sS sB
                                ]
                            Skybox.GSVGSphericalSkybox debug sT ->
                                Html.div [style "position" "absolute", style "left" "0px", style "top" (String.fromInt (unwrapQ model.height) ++ "px")]
                                [
                                    -- Html.h1 [] [Html.text "Skybox Debug"]
                                Html.map SkyboxMsg <| GS.drawSkybox debug model.gSkyboxModel sT (group []) (group [])
                                ]
                            _ -> Html.span [] []
                    ,   Scene3d.custom
                            { lights = lights --Scene3d.oneLight softLighting
                            , camera = model.camera
                            , clipDepth = Length.centimeters 10
                            , exposure = Scene3d.exposureValue 6
                            , toneMapping = Scene3d.hableFilmicToneMapping
                            , whiteBalance = Light.fluorescent
                            , antialiasing = Scene3d.multisampling
                            , dimensions = ( model.width, model.height )
                            , background = Scene3d.backgroundColor Color.lightBlue
                            , entities =  -- baseEntities 
                                           baseEntities ++ renderEntities (renderBodies False model.spaceshipState.world)
                                          ++ renderEntities (spaceGameAssist model)
                                          ++ renderEntities [internalSpaceStation model]
                            }
                            |> withOverlay (overlay model) model
                    ]
            Loading ->
                Html.div []
                    [ Html.text "Loading..."
                    ,  Html.map GSVGTextureMsg <| GT.drawTextures False model.gTextureModel
                    ]

angleDisplay : Model -> Shape Msg
angleDisplay model = group
    [
        text ("azimuth: " ++ String.fromInt (round <| unwrapQ model.azimuth * 180 / pi) ++ "ยบ")
                                |> filled black
                                |> move (toFloat (unwrapQ model.width) / 2 - 160, toFloat (unwrapQ model.height) / 2 - 50)
    ,   text ("elevation: " ++ String.fromInt (round <| unwrapQ model.elevation * 180 / pi) ++ "ยบ")
            |> filled black
            |> move (toFloat (unwrapQ model.width) / 2 - 160, toFloat (unwrapQ model.height) / 2 - 60)
    ]

cameraControls : Model -> Shape Msg
cameraControls model =
    group
        [ group 
            [ roundedRect 60 40 10
              |> filled green
            , text "Reset"
              |> size 16
              |> centered
              |> filled black
              |> move (0,-5)
            ]
            |> move (toFloat (unwrapQ model.width) / 2 - 125, toFloat (unwrapQ model.height) / 2 - 90)
            |> notifyTap Reset
        -- Forward
        , group
            [ roundedRect 40 40 10
              |> filled green
            , text "|"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-2.5)
              |> rotate (degrees 180)
            , text "v"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-7.5)
              |> rotate (degrees 180)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 125, toFloat (unwrapQ model.height) / 2 - 150)
          |> notifyTap (MoveCamera Direction3d.x (Length.centimeters 10))
          -- Backward
          , group
            [ roundedRect 40 40 10
              |> filled green
            , text "|"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-2.5)
            , text "v"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-7.5)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 125, toFloat (unwrapQ model.height) / 2 - 200)
          |> notifyTap (MoveCamera Direction3d.x (Length.centimeters -10))
          -- Left
          , group
            [ roundedRect 40 40 10
              |> filled green
            , text "|"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-2.5)
              |> rotate (degrees -90)
            , text "v"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-7.5)
              |> rotate (degrees -90)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 175, toFloat (unwrapQ model.height) / 2 - 200)
          |> notifyTap (MoveCamera Direction3d.y (Length.centimeters 10))
          -- Right
          , group
            [ roundedRect 40 40 10
              |> filled green
            , text "|"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-2.5)
              |> rotate (degrees 90)
            , text "v"
              |> size 16
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-7.5)
              |> rotate (degrees 90)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 75, toFloat (unwrapQ model.height) / 2 - 200)
          |> notifyTap (MoveCamera Direction3d.y (Length.centimeters -10))
          , group
            [ roundedRect 40 40 10
              |> filled green
            , text "Up"
              |> size 14
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-4)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 175, toFloat (unwrapQ model.height) / 2 - 150)
          |> notifyTap (MoveCamera Direction3d.z (Length.centimeters 10))
          , group
            [ roundedRect 40 40 10
              |> filled green
            , text "Down"
              |> size 14
              |> centered
              |> sansserif
              |> filled black
              |> move (0,-4)
            ]
          |> move (toFloat (unwrapQ model.width) / 2 - 75, toFloat (unwrapQ model.height) / 2 - 150)
          |> notifyTap (MoveCamera Direction3d.z (Length.centimeters -10))
        ]
